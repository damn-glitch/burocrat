// scripts/prisma-prune.js
// pull -> (maybe expand keep) -> prune (drop unknown-type fields, dedupe field names) -> format -> generate -> cleanup

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync } = require('child_process');

const PRISMA_DIR = path.join(__dirname, '..', 'prisma');
const INPUT  = process.env.PRISMA_INPUT  || path.join(PRISMA_DIR, 'schema.client.prisma'); // полный pull
const OUTPUT = process.env.PRISMA_OUTPUT || path.join(PRISMA_DIR, 'schema.dev.prisma');     // итоговая схема
const KEEP_FILE = process.env.KEEP_MODELS_FILE || path.join(PRISMA_DIR, 'keep-models.json');

const DEFAULT_KEEP = [
  "company", "country",
  "document", "employee_company_rel",
  "folder", "industry",
  "invitation", "legal_form",
  "notification", "otp",
  "permissions", "position",
  "project", "role_permission_rel",
  "roles", "settings",
  "task", "task_log",
  "user_notification", "user_role_rel",
  "user_settings", "users",
  "refresh_token",
  "employee_company_rel",
];
const KEEP_VIEWS     = process.env.KEEP_VIEWS === '1';      // view по умолчанию не берём
const PREFER_KIND    = process.env.PREFER_KIND || 'model';  // 'model' | 'view'
const KEEP_INPUT_RAW = process.env.KEEP_INPUT === '1';      // сохранять сырой pull как .raw
const AUTO_ADD_REFS  = process.env.AUTO_ADD_REFS === '1';   // автоматически добавлять недостающие ссылки
const SKIP_ADD_REFS  = process.env.SKIP_ADD_REFS === '1';   // автоматически НЕ добавлять, просто вырезать связи

const BUILTIN = new Set(["Int","BigInt","String","Boolean","DateTime","Decimal","Bytes","Float","Json"]);

function run(cmd) { execSync(cmd, { stdio: 'inherit' }); }

function ensureInputSkeleton() {
  if (!fs.existsSync(INPUT)) {
    const skeleton =
`// AUTOGENERATED skeleton for db pull
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["public"] // если нужно
}

generator client {
  provider = "prisma-client-js"
}
`;
    fs.mkdirSync(path.dirname(INPUT), { recursive: true });
    fs.writeFileSync(INPUT, skeleton, 'utf8');
  }
}

function pull() {
  const schemaArg = `--schema="${INPUT.replace(/\\/g, '/')}"`;
  run(`npx prisma db pull ${schemaArg} --force`);
}

function loadKeepSet() {
  if (process.env.KEEP_MODELS) {
    return new Set(process.env.KEEP_MODELS.split(',').map(s => s.trim().toLowerCase()).filter(Boolean));
  }
  if (fs.existsSync(KEEP_FILE)) {
    try {
      const j = JSON.parse(fs.readFileSync(KEEP_FILE, 'utf8'));
      if (Array.isArray(j.models)) return new Set(j.models.map(s => s.toLowerCase()));
    } catch {}
  }
  return new Set(DEFAULT_KEEP.map(s => s.toLowerCase()));
}

function saveKeepSet(keepSet) {
  fs.mkdirSync(path.dirname(KEEP_FILE), { recursive: true });
  const arr = Array.from(keepSet).sort();
  fs.writeFileSync(KEEP_FILE, JSON.stringify({ models: arr }, null, 2), 'utf8');
  console.log(`Saved updated keep list to: ${KEEP_FILE}`);
}

function parseBlocks(src) {
  const blockRegex = /(^\s*(model|enum|view)\s+([A-Za-z0-9_]+)\s*\{[\s\S]*?\}\s*)/gm;
  const blocks = [];
  let m;
  while ((m = blockRegex.exec(src)) !== null) blocks.push({ full: m[1], kind: m[2], name: m[3] });
  return blocks;
}

function selectKeptBlocks(keepSet, blocks) {
  const kept = [];
  const byName = new Map();
  const tryPush = (b) => {
    const key = b.name.toLowerCase();
    if (b.kind === 'enum') {
      byName.set(key + '__enum__' + kept.length, { kind: 'enum', index: kept.push(b) - 1 });
      return;
    }
    if (b.kind === 'view' && !KEEP_VIEWS) return;
    if (!keepSet.has(key)) return;

    const existing = byName.get(key);
    if (!existing) {
      byName.set(key, { kind: b.kind, index: kept.push(b) - 1 });
      return;
    }
    const preferModel = PREFER_KIND === 'model';
    const better =
      (preferModel && b.kind === 'model' && existing.kind !== 'model') ||
      (!preferModel && b.kind === 'view' && existing.kind !== 'view');
    if (better) {
      kept[existing.index] = b;
      byName.set(key, { kind: b.kind, index: existing.index });
    }
  };
  for (const b of blocks.filter(b => b.kind !== 'view')) tryPush(b);
  for (const b of blocks.filter(b => b.kind === 'view'))  tryPush(b);
  return kept;
}

function collectUnknownRefs(keptBlocks, allowedTypes) {
  const unknown = new Set();
  const fieldRegex = /^\s*([A-Za-z_][A-Za-z0-9_]*)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?(\?)?(?:\s+.*)?$/;
  for (const b of keptBlocks) {
    if (b.kind !== 'model') continue;
    const open  = b.full.indexOf('{');
    const close = b.full.lastIndexOf('}');
    const body  = b.full.slice(open + 1, close);
    for (const line of body.split('\n')) {
      const m = fieldRegex.exec(line);
      if (!m) continue;
      const typeName = m[2];
      if (!BUILTIN.has(typeName) && !allowedTypes.has(typeName)) unknown.add(typeName);
    }
  }
  return unknown;
}

// вырезаем поля с типами, которых нет в allowedTypes (учёт ?, [], многострочных атрибутов поля)
function sanitizeUnknownTypeFields(modelBody, allowedTypes) {
  const lines = modelBody.split('\n');
  const out = [];
  const fieldRegex = /^\s*([A-Za-z_][A-Za-z0-9_]*)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?(\?)?(?:\s+.*)?$/;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const m = fieldRegex.exec(line);
    if (!m) { out.push(line); continue; }

    const typeName = m[2];
    if (BUILTIN.has(typeName) || allowedTypes.has(typeName)) {
      out.push(line);
      continue;
    }

    // удаляем поле + все строки, пока не началась новая декларация поля, @@ или закрывающая скобка
    while (i + 1 < lines.length) {
      const peek = lines[i + 1];
      if (fieldRegex.test(peek) || /^\s*@@/.test(peek) || /^\s*}/.test(peek)) break;
      i++;
    }
  }
  return out.join('\n');
}

// === NEW: дедуп имён полей внутри модели ===
function dedupeFieldNames(modelBody) {
  const lines = modelBody.split('\n');
  const result = [];
  const seen = new Set();
  const fieldRegex = /^(\s*)([A-Za-z_][A-Za-z0-9_]*)\s+([A-Za-z_][A-Za-z0-9_]*)(\[\])?(\?)?(.*)$/;

  // Вытащим блоками: [fieldLine + его атрибутные строки]
  for (let i = 0; i < lines.length; i++) {
    const m = fieldRegex.exec(lines[i]);
    if (!m) { result.push(lines[i]); continue; }

    const indent = m[1], fieldName = m[2], typeName = m[3];
    const restOfLine = (m[4] || '') + (m[5] || '') + (m[6] || '');

    // Собираем атрибутные строки поля (до следующей декларации / @@ / '}')
    const block = [lines[i]];
    let j = i + 1;
    while (j < lines.length) {
      const peek = lines[j];
      if (fieldRegex.test(peek) || /^\s*@@/.test(peek) || /^\s*}/.test(peek)) break;
      block.push(peek);
      j++;
    }
    i = j - 1;

    let newName = fieldName;
    if (seen.has(fieldName)) {
      // кандидаты
      const candidates = [
        typeName,
        `${fieldName}_${typeName}`,
      ];
      let k = 2;
      while (candidates.length < 6) { candidates.push(`${fieldName}_${k++}`); }

      for (const cand of candidates) {
        if (!seen.has(cand)) { newName = cand; break; }
      }
      // переименовываем первую строку блока
      block[0] = `${indent}${newName} ${typeName}${restOfLine}`;
    }

    seen.add(newName);
    result.push(...block);
  }

  return result.join('\n');
}

function formatListSample(items, max = 25) {
  const arr = Array.from(items).sort((a,b)=>a.localeCompare(b));
  if (arr.length <= max) return arr.join(', ');
  return arr.slice(0, max).join(', ') + `, ... (+${arr.length - max} more)`;
}

function askYesNo(q) {
  return new Promise(resolve => {
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    rl.question(q, answer => {
      rl.close();
      resolve(/^y(es)?$/i.test(String(answer).trim()));
    });
  });
}

async function maybeExpandKeepInteractively(keepSet, blocks, enumNames) {
  let changed = false;
  for (let pass = 0; pass < 10; pass++) {
    const keptBlocks = selectKeptBlocks(keepSet, blocks);
    const allowedTypes = new Set([
      ...keptBlocks.filter(b => b.kind === 'model').map(b => b.name),
      ...enumNames
    ]);
    const unknown = collectUnknownRefs(keptBlocks, allowedTypes);
    if (unknown.size === 0) return { keptBlocks, changed };

    if (SKIP_ADD_REFS || !process.stdin.isTTY) return { keptBlocks, changed };
    if (AUTO_ADD_REFS) {
      for (const t of unknown) keepSet.add(t.toLowerCase());
      changed = true;
      continue;
    }

    console.log('\nНайдены модели, на которые ссылаются оставленные модели, но которых нет в разрешённом списке:');
    console.log(formatListSample(unknown));
    const ok = await askYesNo('Добавить ВСЕ эти модели в список и включить их рекурсивно? [y/N] ');
    if (!ok) return { keptBlocks, changed };

    for (const t of unknown) keepSet.add(t.toLowerCase());
    changed = true;
  }
  return { keptBlocks: selectKeptBlocks(keepSet, blocks), changed };
}

async function prune() {
  const src = fs.readFileSync(INPUT, 'utf8');
  const blocks = parseBlocks(src);
  if (!blocks.length) {
    console.error('schema.client.prisma пуст. Проверь DATABASE_URL и доступы.');
    process.exit(3);
  }

  // заголовок
  const firstPos = src.indexOf(blocks[0].full);
  let header = src.slice(0, firstPos);
  if (!/^\s*generator\s+/m.test(header)) {
    header += `

generator client {
  provider = "prisma-client-js"
}
`.trimStart();
  }

  const enumNames = new Set(blocks.filter(b => b.kind === 'enum').map(b => b.name));
  const keepSet = loadKeepSet();

  // интерактивно/авто расширяем список
  const { keptBlocks, changed } = await maybeExpandKeepInteractively(keepSet, blocks, enumNames);
  if (!keptBlocks.length) {
    console.error('После фильтрации 0 блоков. Проверь список разрешённых моделей.');
    process.exit(4);
  }
  if (changed && !process.env.KEEP_MODELS) saveKeepSet(keepSet);

  // разрешённые типы
  const allowedTypes = new Set([
    ...keptBlocks.filter(b => b.kind === 'model').map(b => b.name),
    ...enumNames
  ]);

  // чистим неизвестные связи и дедупим имена полей
  const rebuilt = keptBlocks.map(b => {
    if (b.kind !== 'model') return b.full;
    const open  = b.full.indexOf('{');
    const close = b.full.lastIndexOf('}');
    const before = b.full.slice(0, open + 1);
    const body   = b.full.slice(open + 1, close);
    const after  = b.full.slice(close);

    const cleanBody = sanitizeUnknownTypeFields(body, allowedTypes);
    const deduped   = dedupeFieldNames(cleanBody);
    return before + deduped + after;
  });

  const out = header.trimEnd() + '\n\n' + rebuilt.join('\n\n') + '\n';
  fs.writeFileSync(OUTPUT, out, 'utf8');

  console.log(`Pruned: всего ${blocks.length} блоков; записано ${keptBlocks.length} в ${OUTPUT}.`);
}

function formatAndGenerate() {
  const schemaArg = `--schema="${OUTPUT.replace(/\\/g, '/')}"`;
  run(`npx prisma format ${schemaArg}`);
  run(`npx prisma generate ${schemaArg}`);
}

function cleanup() {
  try {
    if (!fs.existsSync(INPUT)) return;
    if (KEEP_INPUT_RAW) {
      const dstDir = path.join(PRISMA_DIR, '_introspect');
      fs.mkdirSync(dstDir, { recursive: true });
      const dstPath = path.join(dstDir, 'schema.client.prisma.raw');
      fs.renameSync(INPUT, dstPath);
      console.log(`Raw pull перемещён в: ${dstPath}`);
    } else {
      fs.unlinkSync(INPUT);
      console.log(`Удалён временный файл: ${INPUT}`);
    }
  } catch (e) {
    console.warn(`Не удалось прибрать ${INPUT}: ${e.message}`);
  }
}

(async () => {
  try {
    ensureInputSkeleton();
    pull();
    await prune();
    formatAndGenerate();
    cleanup();
    console.log('✅ Готово.');
  } catch (e) {
    console.error('Ошибка:', e?.message || e);
    process.exit(1);
  }
})();
